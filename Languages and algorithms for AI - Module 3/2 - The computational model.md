# The computational model aka Turing Machines

A computational model computes some specific functions on strings, taking a binary string of arbitrary length, and outputting a single bit.
These are called **characteristic functions**, corresponding to decision problems/languages.

This computational model is made by:
- a finite set of instructions, each of which can be executed more than once;
- a scratchpad in which the CPU can read and write;
-  the input and the output.

This model has the peculiar feature that each instance (finite set of instruction) of it can be encoded itself as a machine.
Actually, in the model we can observe this by proving that there exists the universal Turing Machine, a particular instance of this which simulates all the other machines.
This does nothing less than taking in input a pair of strings <img src="svgs/d23d97bba5b8b6cd5a3b42d24a735d35.svg?invert_in_darkmode" align=middle width=40.06280189999999pt height=24.65753399999998pt/>, and simulating the input of the machine of index <img src="svgs/c745b9b57c145ec5577b82542b2df546.svg?invert_in_darkmode" align=middle width=10.57650494999999pt height=14.15524440000002pt/> with the input <img src="svgs/332cc365a4987aacce0ead01b8bdcc0b.svg?invert_in_darkmode" align=middle width=9.39498779999999pt height=14.15524440000002pt/>. This is basically an interpreter: it takes a program and an input and produces an output!

Actually, the simulation is quite efficient: if the original machine works in time <img src="svgs/4f4f4e395762a3af4575de74c019ebb5.svg?invert_in_darkmode" align=middle width=5.936097749999991pt height=20.221802699999984pt/>, then the universal machine takes a time which is slightly more, just with a logarithmic overhead.
The functions which can be computed by Turing Machines do not completely saturate the space of all functions: they are infinitely many, some of them are intrinsically uncomputable. 

## The model, formally

We want to be able to precisely and formally state theorems about the computable functions: we therefore need a mathematical definition. If we didn't give a definition, anybody could say *well, that scratchpad could contain this, and we could solve that*. Let's first take a look at the scratchpad: this is actually called the worktape in Turing Machines. We can think about it as a sequence of cells, each of which containing a binary digit, and the machine cannot access the tape at the place it wants: at every moment, it points to a specific cell in the tape, the *head*. In the case of the work tape, it is R/W. There's also the input tape (R only) and the output tape (R/W). We can only read from the input, not modify it. These tapes are infinite, though at every moment only a finite set of this has a value different from blank. We also have many blank cells in the work tape: the machine has never accessed these cells so far. The initial value of any cell is blank. The output tape is where the output of the computation is written. Then, what we have in the machine is a **state**: this is stored in a specific register, able to only hold a finite amount of information, since the number of states is finite. Basically, the state tells us *write something there, read something here, move the tape forward, bla bla bla*. It basically reacts to symbols it reads, and moves tapes accordingly. For different states, the way the machine reacts could be different. 

### Scratchpads

A scratchpad consists of <img src="svgs/63bb9849783d01d91403bc9a5fea12a2.svg?invert_in_darkmode" align=middle width=9.075367949999992pt height=22.831056599999986pt/> tapes: there can be any number of tapes. Any of these is a line of cells infinite in one direction, holding values from a finite alphabet. Each of this has a head, which can read or write, and move left or right. The first tape is always the input tape. There could exist machines with no input or output: they may collapse to just one tape. Instead, other machines can have much more than 3 tapes. The only point is that <img src="svgs/63bb9849783d01d91403bc9a5fea12a2.svg?invert_in_darkmode" align=middle width=9.075367949999992pt height=22.831056599999986pt/> cannot change during computation. 

### Instructions

The movement of the head is regulated by the **instructions**, and the machine has a finite set of states called <img src="svgs/1afcdb0f704394b16fe85fb40c45ca7a.svg?invert_in_darkmode" align=middle width=12.99542474999999pt height=22.465723500000017pt/>. At each step, the machine does the following:
1. it reads the symbols under the <img src="svgs/63bb9849783d01d91403bc9a5fea12a2.svg?invert_in_darkmode" align=middle width=9.075367949999992pt height=22.831056599999986pt/> tape heads
2. for the <img src="svgs/aa9d1dc08f682f546eeee2869762ff90.svg?invert_in_darkmode" align=middle width=37.38576269999999pt height=22.831056599999986pt/> R/W tapes it replaces the symbol with a new one or leave it unchanged
3. it may change the state to a new one
4. it may move the heads

These instructions are super basic: we cannot think about arithmetic operations, just some finite amount of information that produces some necessary information required to modify the internal state of the machine. 

### Turing machines

We can now define a **Turing Machine** TM working on <img src="svgs/63bb9849783d01d91403bc9a5fea12a2.svg?invert_in_darkmode" align=middle width=9.075367949999992pt height=22.831056599999986pt/> tapes, described as a triple made of 

* An alphabet <img src="svgs/b2af456716f3117a91da7afe70758041.svg?invert_in_darkmode" align=middle width=10.274003849999989pt height=22.465723500000017pt/>, a finite set of tape symbols, namely those symbols that can be found in the tapes. These symbols must include the blank symbol (<img src="svgs/0b9d9d47eccbab9e6ec6b81d31931ffc.svg?invert_in_darkmode" align=middle width=12.785434199999989pt height=22.19178720000002pt/>, the box), the start symbol (<img src="svgs/7e5d45902831d515c10ea25aa8db492c.svg?invert_in_darkmode" align=middle width=12.785434199999989pt height=18.0775881pt/>), and the binary digits 0 and 1. There can be more, for example A,B,C,3,5...

* A finite set of **states** <img src="svgs/1afcdb0f704394b16fe85fb40c45ca7a.svg?invert_in_darkmode" align=middle width=12.99542474999999pt height=22.465723500000017pt/> (including a designated initial state <img src="svgs/d60a15b1efe7481be0b05c16c7b637ad.svg?invert_in_darkmode" align=middle width=35.38903829999999pt height=22.465723500000017pt/> and a designated final state <img src="svgs/3e8c6c206c6923d1289e7f150888c154.svg?invert_in_darkmode" align=middle width=37.011412349999986pt height=22.465723500000017pt/>)

* A **transition function**, what really matters, i.e. the actual program. this models how the machine reacts to input and produces outputs. Nothing more than a function taking the current state (element of <img src="svgs/1afcdb0f704394b16fe85fb40c45ca7a.svg?invert_in_darkmode" align=middle width=12.99542474999999pt height=22.465723500000017pt/>), a vector of length k (the symbols the machine reads form the tapes) from the alphabet <img src="svgs/b2af456716f3117a91da7afe70758041.svg?invert_in_darkmode" align=middle width=10.274003849999989pt height=22.465723500000017pt/>, and produces an output containing the next state (element of <img src="svgs/1afcdb0f704394b16fe85fb40c45ca7a.svg?invert_in_darkmode" align=middle width=12.99542474999999pt height=22.465723500000017pt/>), then the symbols it puts into the <img src="svgs/aa9d1dc08f682f546eeee2869762ff90.svg?invert_in_darkmode" align=middle width=37.38576269999999pt height=22.831056599999986pt/> R/W tapes (work tapes and output tapes), then a vector of length <img src="svgs/63bb9849783d01d91403bc9a5fea12a2.svg?invert_in_darkmode" align=middle width=9.075367949999992pt height=22.831056599999986pt/> made with an alphabet composed of <img src="svgs/ddcb483302ed36a59286424aa5e0be17.svg?invert_in_darkmode" align=middle width=11.18724254999999pt height=22.465723500000017pt/> (move the corresponding head to left), <img src="svgs/e257acd1ccbe7fcb654708f1a866bfe9.svg?invert_in_darkmode" align=middle width=11.027402099999989pt height=22.465723500000017pt/> (let the head <img src="svgs/77a3b857d53fb44e33b53e4c8b68351a.svg?invert_in_darkmode" align=middle width=5.663225699999989pt height=21.68300969999999pt/> stay in place), <img src="svgs/1e438235ef9ec72fc51ac5025516017c.svg?invert_in_darkmode" align=middle width=12.60847334999999pt height=22.465723500000017pt/> (move the head to right). This can be expressed formally as:
<p align="center"><img src="svgs/a42906db4cfae54049d089f6f5cf3304.svg?invert_in_darkmode" align=middle width=251.97198674999999pt height=18.88772655pt/></p>

This function only includes a **finite amount of information**, so the possible inputs are finite and the possible outputs are finite.
Now, there is one thing to say: when the first parameter is <img src="svgs/d8746fd75da8832672e018f29e6e103e.svg?invert_in_darkmode" align=middle width=31.354299899999987pt height=14.15524440000002pt/>, the tapes/heads cannot be touched, so we take for granted that: 
<p align="center"><img src="svgs/4ba859eb030d2a2cb4f02daeadaea3b9.svg?invert_in_darkmode" align=middle width=383.47549515pt height=16.438356pt/></p>
meaning that the machine stays in this position.

The Turing Machine can be referred as <img src="svgs/733e23cc17dc1982d8f582c9b3008985.svg?invert_in_darkmode" align=middle width=100.25315354999998pt height=24.65753399999998pt/>.

Now, the current state of the machine is not just the current state <img src="svgs/d5c18a8ca1894fd3a7d25f242cbe8890.svg?invert_in_darkmode" align=middle width=7.928106449999989pt height=14.15524440000002pt/>, but the **configuration**, composed of <img src="svgs/d5c18a8ca1894fd3a7d25f242cbe8890.svg?invert_in_darkmode" align=middle width=7.928106449999989pt height=14.15524440000002pt/>, the contents of the <img src="svgs/63bb9849783d01d91403bc9a5fea12a2.svg?invert_in_darkmode" align=middle width=9.075367949999992pt height=22.831056599999986pt/> tapes, and the position of the <img src="svgs/63bb9849783d01d91403bc9a5fea12a2.svg?invert_in_darkmode" align=middle width=9.075367949999992pt height=22.831056599999986pt/> heads! One such configuration will be indicated as <img src="svgs/9b325b9e31e85137d1de765f43c0f8bc.svg?invert_in_darkmode" align=middle width=12.92464304999999pt height=22.465723500000017pt/>.

Given the input <img src="svgs/6757750c110305df24531014890f7d2b.svg?invert_in_darkmode" align=middle width=76.40404199999999pt height=24.65753399999998pt/>, in the initial configuration <img src="svgs/7fa77f21e3d37d591ed8249c8d1511d9.svg?invert_in_darkmode" align=middle width=16.40531474999999pt height=22.465723500000017pt/> the state is <img src="svgs/ca3d2c576765a38a35d55636569f3ff6.svg?invert_in_darkmode" align=middle width=29.73192584999999pt height=14.15524440000002pt/>, the input  tape contains <img src="svgs/a731c360f4cd8c00808b1aa9361e0aef.svg?invert_in_darkmode" align=middle width=22.180421999999993pt height=18.0775881pt/>, work and output tape contain <img src="svgs/7e5d45902831d515c10ea25aa8db492c.svg?invert_in_darkmode" align=middle width=12.785434199999989pt height=18.0775881pt/> and the tape heads are positioned on the first symbol of their tape.

TMs are an interesting strategy of showing that a function is computable. The point is that computing it in another way is still a good proof. So, why are we obsessed with these fucking Turing Machines? We cannot get negative results with these! The border between what can be done and what can't be done is exactly what we are searching for.

We usually ask the TM to compute things in a bounded amount of steps: <img src="svgs/2f118ee06d05f3c2d98361d9c30e38ce.svg?invert_in_darkmode" align=middle width=11.889314249999991pt height=22.465723500000017pt/> is a bound, not in the strict sense, rather in a function sense.
If we say that a function  is computed in time <img src="svgs/2f118ee06d05f3c2d98361d9c30e38ce.svg?invert_in_darkmode" align=middle width=11.889314249999991pt height=22.465723500000017pt/>, we insist on <img src="svgs/2f118ee06d05f3c2d98361d9c30e38ce.svg?invert_in_darkmode" align=middle width=11.889314249999991pt height=22.465723500000017pt/> to be a function: it would be non-sense to require the computational time to be fixed for different inputs.
The time bound is dependent on the length on the input! What matters about the input is its length: **if an input is longer, we'll allow the machine to take a longer time.**

Given <img src="svgs/4f1a904c0e5857860ddd7875e5ad4306.svg?invert_in_darkmode" align=middle width=143.74415879999998pt height=24.65753399999998pt/> and <img src="svgs/17726fa8b5401d1429efa4fd9faad060.svg?invert_in_darkmode" align=middle width=74.90269049999998pt height=22.648391699999998pt/>, these are equivalent:
* <img src="svgs/190083ef7a1625fbc75f243cffb9c96d.svg?invert_in_darkmode" align=middle width=9.81741584999999pt height=22.831056599999986pt/> is **computable** in time <img src="svgs/2f118ee06d05f3c2d98361d9c30e38ce.svg?invert_in_darkmode" align=middle width=11.889314249999991pt height=22.465723500000017pt/>.
* A TM <img src="svgs/b5eaea000e06d5cf2e882f8fdbc71e36.svg?invert_in_darkmode" align=middle width=19.740822749999992pt height=22.465723500000017pt/> computes <img src="svgs/190083ef7a1625fbc75f243cffb9c96d.svg?invert_in_darkmode" align=middle width=9.81741584999999pt height=22.831056599999986pt/> in time <img src="svgs/2f118ee06d05f3c2d98361d9c30e38ce.svg?invert_in_darkmode" align=middle width=11.889314249999991pt height=22.465723500000017pt/>.
* <img src="svgs/b5eaea000e06d5cf2e882f8fdbc71e36.svg?invert_in_darkmode" align=middle width=19.740822749999992pt height=22.465723500000017pt/> returns <img src="svgs/7997339883ac20f551e7f35efff0a2b9.svg?invert_in_darkmode" align=middle width=31.99783454999999pt height=24.65753399999998pt/> on input <img src="svgs/332cc365a4987aacce0ead01b8bdcc0b.svg?invert_in_darkmode" align=middle width=9.39498779999999pt height=14.15524440000002pt/> in a number of steps smaller or equal to <img src="svgs/e18f5368eef23283466ccea0c1fc465e.svg?invert_in_darkmode" align=middle width=128.73866939999996pt height=24.65753399999998pt/>. 

Then, we can finally say that a **language** <img src="svgs/030a95852438e9a9a99e23999ebb92a5.svg?invert_in_darkmode" align=middle width=88.69526819999999pt height=24.65753399999998pt/> is decidable in time <img src="svgs/2f118ee06d05f3c2d98361d9c30e38ce.svg?invert_in_darkmode" align=middle width=11.889314249999991pt height=22.465723500000017pt/> if and only if <img src="svgs/190083ef7a1625fbc75f243cffb9c96d.svg?invert_in_darkmode" align=middle width=9.81741584999999pt height=22.831056599999986pt/> is computable in time <img src="svgs/2f118ee06d05f3c2d98361d9c30e38ce.svg?invert_in_darkmode" align=middle width=11.889314249999991pt height=22.465723500000017pt/>.

A function <img src="svgs/17726fa8b5401d1429efa4fd9faad060.svg?invert_in_darkmode" align=middle width=74.90269049999998pt height=22.648391699999998pt/> is **time-constructible** if the function itself can be computed on a Turing Machine (i.e. <img src="svgs/8d6cf5fa5a662cc93e0a9cdb1c3c0029.svg?invert_in_darkmode" align=middle width=85.53648839999998pt height=24.65753399999998pt/> <img src="svgs/c98b21c77c765ccc40a78b2c09de2c87.svg?invert_in_darkmode" align=middle width=92.77967984999998pt height=24.65753399999998pt/> is computable). 

How robust is our definition? There are many details that are arbitrary.
We have chosen this not because it's the best, but because it's okay. For example, rather than having an alphabet for the tapes we may restrict it to the minimal, or restrict the number of tapes, or make the tapes infinite in both directions, etc.
However it can be proved that these more restrictive notions of TM simulate the more general one, with polynomial overhead, so they are equivalent.

What keeps our definition so simple is that describing it is just describing the transition function <img src="svgs/38f1e2a089e53d5c990a82f284948953.svg?invert_in_darkmode" align=middle width=7.928075099999989pt height=22.831056599999986pt/>: the states are finitely many, the symbols are finite, the tapes too. So, the description is nothing more than the description of this subset. 

We can state that there exists a **Universal Turing Machine** (UTM) <img src="svgs/e06ba62f2bfed5cf8a0fae61c45d4ac8.svg?invert_in_darkmode" align=middle width=11.92007189999999pt height=22.465723500000017pt/>, a TM which can generate all the TMs from their description, halting with just an additional logaritmic overhead (hence it can be used to efficiently simulate all TMs). More formally, <img src="svgs/712dea194ef964930c94cf62019c28ca.svg?invert_in_darkmode" align=middle width=103.41886994999999pt height=24.65753399999998pt/> (where <img src="svgs/c745b9b57c145ec5577b82542b2df546.svg?invert_in_darkmode" align=middle width=10.57650494999999pt height=14.15524440000002pt/> represents the TM <img src="svgs/05beb6c47c8a22749d77a8aa93894035.svg?invert_in_darkmode" align=middle width=28.28673704999999pt height=22.465723500000017pt/>):
* <img src="svgs/e193034da292c85fbab3a06126a30be4.svg?invert_in_darkmode" align=middle width=125.18956889999997pt height=24.65753399999998pt/>
* <img src="svgs/a104cfd72c2dc39b03399351613caf40.svg?invert_in_darkmode" align=middle width=51.28907024999999pt height=24.65753399999998pt/> halts within <img src="svgs/2f118ee06d05f3c2d98361d9c30e38ce.svg?invert_in_darkmode" align=middle width=11.889314249999991pt height=22.465723500000017pt/> steps <img src="svgs/93d3db69d03e97544e769f35b11bfcb6.svg?invert_in_darkmode" align=middle width=72.9873705pt height=24.65753399999998pt/> halts within <img src="svgs/89be744ebdd108467eadff0f85c9f80c.svg?invert_in_darkmode" align=middle width=67.65042899999999pt height=24.65753399999998pt/> steps (where <img src="svgs/3e18a4a28fdee1744e5e3f79d13b9ff6.svg?invert_in_darkmode" align=middle width=7.11380504999999pt height=14.15524440000002pt/> depends only on <img src="svgs/05beb6c47c8a22749d77a8aa93894035.svg?invert_in_darkmode" align=middle width=28.28673704999999pt height=22.465723500000017pt/>, not on <img src="svgs/332cc365a4987aacce0ead01b8bdcc0b.svg?invert_in_darkmode" align=middle width=9.39498779999999pt height=14.15524440000002pt/>)

We can even state that there exists a function <img src="svgs/d39d605ce0776dc6f15cf282910c7773.svg?invert_in_darkmode" align=middle width=16.524076799999992pt height=14.15524440000002pt/> that is not computable by any TM: the proof is constructive. Before being able to return 0, the following function has to wait until this process finishes. We'd want to wait that it is over, and that is not possible!
<p align="center"><img src="svgs/cfdd6acf272fa9ac2f827d45a48fc2fe.svg?invert_in_darkmode" align=middle width=210.164559pt height=39.452455349999994pt/></p>

If this was computable, there would exist a TM able to compute this for every <img src="svgs/c745b9b57c145ec5577b82542b2df546.svg?invert_in_darkmode" align=middle width=10.57650494999999pt height=14.15524440000002pt/>. This is a contradiction: it's like saying factorial of 3 is equal to 6 if and only if factorial of 3 is 7. Only one can be true! Why do we have this if and only if chain? If it returns 1, we must be on the *otherwise* branch. So how do we change branch? If <img src="svgs/fb97d38bcc19230b0acd442e17db879c.svg?invert_in_darkmode" align=middle width=17.73973739999999pt height=22.465723500000017pt/> is different from 1 it must be 0, there is no other way. <img src="svgs/fb97d38bcc19230b0acd442e17db879c.svg?invert_in_darkmode" align=middle width=17.73973739999999pt height=22.465723500000017pt/> is equal to <img src="svgs/d39d605ce0776dc6f15cf282910c7773.svg?invert_in_darkmode" align=middle width=16.524076799999992pt height=14.15524440000002pt/>, and on the one hand we used the second definition, while on the other hand we used the other equation. We can't go from a statement to the other! Why did we manage to prove this? There's a mechanism here called *diagonalization*: we see it as <img src="svgs/c745b9b57c145ec5577b82542b2df546.svg?invert_in_darkmode" align=middle width=10.57650494999999pt height=14.15524440000002pt/> is used twice, as input and as output.
<p align="center"><img src="svgs/d4629a1de311965c3057ee7e65d194f5.svg?invert_in_darkmode" align=middle width=341.2347246pt height=16.438356pt/></p>
 This is the root of the problem. The incompleteness theorem we studied at the beginning relies on this too. This allows for negative results both in logic and CS. 

A *diophantine equation* is a polynomial equality with integer coefficients and finitely many unknowns. 

We want a language to be semantic, i.e. whenever an encoding of a Turing Machine is in the language and there exists a TM which computes the same function as <img src="svgs/fb97d38bcc19230b0acd442e17db879c.svg?invert_in_darkmode" align=middle width=17.73973739999999pt height=22.465723500000017pt/>, also the encoding of that TM is in that language. 

#
[Previous section](1%20-%20Sets%20and%20numbers.md) Â· [Next section](3%20-%20Polynomial%20time%20computable%20problems.md)
